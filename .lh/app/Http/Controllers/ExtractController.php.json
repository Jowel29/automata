{
    "sourceFile": "app/Http/Controllers/ExtractController.php",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 8,
            "patches": [
                {
                    "date": 1762469552741,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1762469563555,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -43,9 +43,8 @@\n             $filename = is_array($pdfInfo) ? $pdfInfo['filename'] : $pdfInfo;\n             $pdfPath = Storage::disk('public')->path('pdf/' . $filename);\n \n             try {\n-                // Check if file exists\n                 if (!file_exists($pdfPath)) {\n                     $extractedData[] = array_merge(\n                         ['file' => $filename, 'status' => 'File not found'],\n                         array_fill_keys(array_column($fields, 'name'), 'N/A')\n"
                },
                {
                    "date": 1762469570261,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -91,9 +91,8 @@\n \n         $start = preg_quote($start, '/');\n         $end = $end ? preg_quote($end, '/') : '$';\n \n-        // Add word boundaries and better whitespace handling\n         $pattern = '/' . $start . '\\s*(.*?)' . $end . '/su';\n \n         if (preg_match($pattern, $text, $matches)) {\n             return trim($matches[1]) ?: 'Empty';\n"
                },
                {
                    "date": 1762471288972,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,6 @@\n <?php\n+\n namespace App\\Http\\Controllers;\n \n use Illuminate\\Http\\Request;\n use Illuminate\\Support\\Facades\\Storage;\n@@ -82,22 +83,116 @@\n \n         return view('pdf.results', compact('extractedData'));\n     }\n \n+    /**\n+     * استخراج قيمة الحقل بطريقة محسّنة\n+     */\n     private function extractFieldValue(?string $text, ?string $start, ?string $end): string\n     {\n         if (empty($text) || empty($start)) {\n             return 'Not found';\n         }\n \n+        // تنظيف النص من المسافات الزائدة\n+        $text = preg_replace('/\\s+/', ' ', $text);\n+\n         $start = preg_quote($start, '/');\n-        $end = $end ? preg_quote($end, '/') : '$';\n \n-        $pattern = '/' . $start . '\\s*(.*?)' . $end . '/su';\n+        // إذا كان هناك end keyword\n+        if (!empty($end)) {\n+            $end = preg_quote($end, '/');\n+            // استخراج النص بين start و end مع إزالة المسافات الزائدة\n+            $pattern = '/' . $start . '\\s*([^\\n]*?)\\s*' . $end . '/su';\n+        } else {\n+            // استخراج حتى نهاية السطر أو أي رقم/حرف جديد\n+            // هذا النمط يتوقف عند أول سطر جديد أو كلمة مفتاحية شائعة\n+            $pattern = '/' . $start . '\\s*([^\\n\\r]*?)(?=\\s*(?:Age:|Gender:|Phone:|Email:|Address:|\\n|$))/su';\n+        }\n \n         if (preg_match($pattern, $text, $matches)) {\n-            return trim($matches[1]) ?: 'Empty';\n+            $value = trim($matches[1]);\n+            // إزالة أي أحرف غير مرغوبة\n+            $value = preg_replace('/\\s+/', ' ', $value);\n+            return $value ?: 'Empty';\n         }\n \n         return 'Not found';\n     }\n+\n+    /**\n+     * طريقة بديلة: استخراج متعدد الحقول تلقائياً\n+     * هذه تستخرج كل الحقول الشائعة تلقائياً\n+     */\n+    private function extractCommonFields(string $text): array\n+    {\n+        $result = [];\n+\n+        // قائمة الحقول الشائعة\n+        $commonFields = [\n+            'Name' => 'Name:',\n+            'Age' => 'Age:',\n+            'Gender' => 'Gender:',\n+            'Phone' => 'Phone:',\n+            'Email' => 'Email:',\n+            'Address' => 'Address:',\n+        ];\n+\n+        // تنظيف النص\n+        $text = preg_replace('/\\s+/', ' ', $text);\n+\n+        foreach ($commonFields as $fieldName => $keyword) {\n+            $pattern = '/' . preg_quote($keyword, '/') . '\\s*([^\\n]*?)(?=\\s*(?:Name:|Age:|Gender:|Phone:|Email:|Address:|\\n|$))/su';\n+\n+            if (preg_match($pattern, $text, $matches)) {\n+                $result[$fieldName] = trim($matches[1]);\n+            } else {\n+                $result[$fieldName] = 'Not found';\n+            }\n+        }\n+\n+        return $result;\n+    }\n+\n+    /**\n+     * طريقة متقدمة: استخراج ذكي بناءً على الأنماط\n+     */\n+    private function smartExtract(string $text, array $fields): array\n+    {\n+        $result = [];\n+\n+        // تحويل النص إلى أسطر\n+        $lines = preg_split('/\\r\\n|\\r|\\n/', $text);\n+\n+        foreach ($fields as $field) {\n+            $keyword = $field['start_keyword'] ?? '';\n+            if (empty($keyword)) {\n+                $result[$field['name']] = 'Not found';\n+                continue;\n+            }\n+\n+            $found = false;\n+            foreach ($lines as $line) {\n+                $line = trim($line);\n+\n+                // البحث عن الكلمة المفتاحية في السطر\n+                if (stripos($line, $keyword) !== false) {\n+                    // استخراج القيمة بعد الكلمة المفتاحية\n+                    $value = trim(str_ireplace($keyword, '', $line));\n+\n+                    // إزالة أي كلمات مفتاحية أخرى قد تكون في نفس السطر\n+                    $value = preg_split('/\\s+(?:Age:|Gender:|Phone:|Email:)/i', $value)[0];\n+\n+                    $result[$field['name']] = trim($value) ?: 'Empty';\n+                    $found = true;\n+                    break;\n+                }\n+            }\n+\n+            if (!$found) {\n+                $result[$field['name']] = 'Not found';\n+            }\n+        }\n+\n+        return $result;\n+    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1762471308473,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,5 @@\n <?php\n-\n namespace App\\Http\\Controllers;\n \n use Illuminate\\Http\\Request;\n use Illuminate\\Support\\Facades\\Storage;\n@@ -83,116 +82,22 @@\n \n         return view('pdf.results', compact('extractedData'));\n     }\n \n-    /**\n-     * استخراج قيمة الحقل بطريقة محسّنة\n-     */\n     private function extractFieldValue(?string $text, ?string $start, ?string $end): string\n     {\n         if (empty($text) || empty($start)) {\n             return 'Not found';\n         }\n \n-        // تنظيف النص من المسافات الزائدة\n-        $text = preg_replace('/\\s+/', ' ', $text);\n-\n         $start = preg_quote($start, '/');\n+        $end = $end ? preg_quote($end, '/') : '$';\n \n-        // إذا كان هناك end keyword\n-        if (!empty($end)) {\n-            $end = preg_quote($end, '/');\n-            // استخراج النص بين start و end مع إزالة المسافات الزائدة\n-            $pattern = '/' . $start . '\\s*([^\\n]*?)\\s*' . $end . '/su';\n-        } else {\n-            // استخراج حتى نهاية السطر أو أي رقم/حرف جديد\n-            // هذا النمط يتوقف عند أول سطر جديد أو كلمة مفتاحية شائعة\n-            $pattern = '/' . $start . '\\s*([^\\n\\r]*?)(?=\\s*(?:Age:|Gender:|Phone:|Email:|Address:|\\n|$))/su';\n-        }\n+        $pattern = '/' . $start . '\\s*(.*?)' . $end . '/su';\n \n         if (preg_match($pattern, $text, $matches)) {\n-            $value = trim($matches[1]);\n-            // إزالة أي أحرف غير مرغوبة\n-            $value = preg_replace('/\\s+/', ' ', $value);\n-            return $value ?: 'Empty';\n+            return trim($matches[1]) ?: 'Empty';\n         }\n \n         return 'Not found';\n     }\n-\n-    /**\n-     * طريقة بديلة: استخراج متعدد الحقول تلقائياً\n-     * هذه تستخرج كل الحقول الشائعة تلقائياً\n-     */\n-    private function extractCommonFields(string $text): array\n-    {\n-        $result = [];\n-\n-        // قائمة الحقول الشائعة\n-        $commonFields = [\n-            'Name' => 'Name:',\n-            'Age' => 'Age:',\n-            'Gender' => 'Gender:',\n-            'Phone' => 'Phone:',\n-            'Email' => 'Email:',\n-            'Address' => 'Address:',\n-        ];\n-\n-        // تنظيف النص\n-        $text = preg_replace('/\\s+/', ' ', $text);\n-\n-        foreach ($commonFields as $fieldName => $keyword) {\n-            $pattern = '/' . preg_quote($keyword, '/') . '\\s*([^\\n]*?)(?=\\s*(?:Name:|Age:|Gender:|Phone:|Email:|Address:|\\n|$))/su';\n-\n-            if (preg_match($pattern, $text, $matches)) {\n-                $result[$fieldName] = trim($matches[1]);\n-            } else {\n-                $result[$fieldName] = 'Not found';\n-            }\n-        }\n-\n-        return $result;\n-    }\n-\n-    /**\n-     * طريقة متقدمة: استخراج ذكي بناءً على الأنماط\n-     */\n-    private function smartExtract(string $text, array $fields): array\n-    {\n-        $result = [];\n-\n-        // تحويل النص إلى أسطر\n-        $lines = preg_split('/\\r\\n|\\r|\\n/', $text);\n-\n-        foreach ($fields as $field) {\n-            $keyword = $field['start_keyword'] ?? '';\n-            if (empty($keyword)) {\n-                $result[$field['name']] = 'Not found';\n-                continue;\n-            }\n-\n-            $found = false;\n-            foreach ($lines as $line) {\n-                $line = trim($line);\n-\n-                // البحث عن الكلمة المفتاحية في السطر\n-                if (stripos($line, $keyword) !== false) {\n-                    // استخراج القيمة بعد الكلمة المفتاحية\n-                    $value = trim(str_ireplace($keyword, '', $line));\n-\n-                    // إزالة أي كلمات مفتاحية أخرى قد تكون في نفس السطر\n-                    $value = preg_split('/\\s+(?:Age:|Gender:|Phone:|Email:)/i', $value)[0];\n-\n-                    $result[$field['name']] = trim($value) ?: 'Empty';\n-                    $found = true;\n-                    break;\n-                }\n-            }\n-\n-            if (!$found) {\n-                $result[$field['name']] = 'Not found';\n-            }\n-        }\n-\n\\ No newline at end of file\n-        return $result;\n-    }\n-}\n+}\n"
                },
                {
                    "date": 1762471866731,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -83,21 +83,28 @@\n         return view('pdf.results', compact('extractedData'));\n     }\n \n     private function extractFieldValue(?string $text, ?string $start, ?string $end): string\n-    {\n-        if (empty($text) || empty($start)) {\n-            return 'Not found';\n-        }\n+{\n+    if (empty($text) || empty($start)) {\n+        return 'Not found';\n+    }\n \n-        $start = preg_quote($start, '/');\n-        $end = $end ? preg_quote($end, '/') : '$';\n+    $start = preg_quote($start, '/');\n+    $end = $end ? preg_quote($end, '/') : null;\n \n-        $pattern = '/' . $start . '\\s*(.*?)' . $end . '/su';\n+    if ($end) {\n+        // إذا تم تحديد end_keyword، استخدمه بشكل طبيعي\n+        $pattern = '/' . $start . '\\s*(.*?)\\s*' . $end . '/su';\n+    } else {\n+        // إذا لم يتم تحديد end_keyword، خذ السطر فقط بعد الكلمة المفتاحية\n+        $pattern = '/' . $start . '\\s*([^\\r\\n]+)/su';\n+    }\n \n-        if (preg_match($pattern, $text, $matches)) {\n-            return trim($matches[1]) ?: 'Empty';\n-        }\n+    if (preg_match($pattern, $text, $matches)) {\n+        return trim($matches[1]) ?: 'Empty';\n+    }\n \n-        return 'Not found';\n-    }\n+    return 'Not found';\n }\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1762471873981,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,108 @@\n+<?php\n+namespace App\\Http\\Controllers;\n+\n+use Illuminate\\Http\\Request;\n+use Illuminate\\Support\\Facades\\Storage;\n+use Smalot\\PdfParser\\Parser;\n+\n+class ExtractController extends Controller\n+{\n+    public function showFieldsForm()\n+    {\n+        $uploadedPdfs = session('uploaded_pdfs', []);\n+\n+        if (empty($uploadedPdfs)) {\n+            return redirect()->route('pdf.upload')\n+                ->with('error', 'Please upload at least one PDF first.');\n+        }\n+\n+        return view('pdf.fields', compact('uploadedPdfs'));\n+    }\n+\n+    public function extractData(Request $request)\n+    {\n+        $request->validate([\n+            'fields' => 'required|array|min:1',\n+            'fields.*.name' => 'required|string|max:255',\n+            'fields.*.start_keyword' => 'nullable|string',\n+            'fields.*.end_keyword' => 'nullable|string',\n+        ]);\n+\n+        $fields = $request->input('fields', []);\n+        $uploadedPdfs = session('uploaded_pdfs', []);\n+\n+        if (empty($uploadedPdfs) || empty($fields)) {\n+            return redirect()->back()\n+                ->with('error', 'Please upload PDFs and define fields first.');\n+        }\n+\n+        $extractedData = [];\n+        $parser = new Parser();\n+\n+        foreach ($uploadedPdfs as $pdfInfo) {\n+            $filename = is_array($pdfInfo) ? $pdfInfo['filename'] : $pdfInfo;\n+            $pdfPath = Storage::disk('public')->path('pdf/' . $filename);\n+\n+            try {\n+                if (!file_exists($pdfPath)) {\n+                    $extractedData[] = array_merge(\n+                        ['file' => $filename, 'status' => 'File not found'],\n+                        array_fill_keys(array_column($fields, 'name'), 'N/A')\n+                    );\n+                    continue;\n+                }\n+\n+                $pdf = $parser->parseFile($pdfPath);\n+                $text = $pdf->getText();\n+\n+                $pdfResult = [\n+                    'file' => is_array($pdfInfo) ? $pdfInfo['original_name'] : $filename,\n+                    'status' => 'Success'\n+                ];\n+\n+                foreach ($fields as $field) {\n+                    $pdfResult[$field['name']] = $this->extractFieldValue(\n+                        $text,\n+                        $field['start_keyword'] ?? null,\n+                        $field['end_keyword'] ?? null\n+                    );\n+                }\n+\n+                $extractedData[] = $pdfResult;\n+\n+            } catch (\\Exception $e) {\n+                $extractedData[] = array_merge(\n+                    ['file' => $filename, 'status' => 'Error: ' . $e->getMessage()],\n+                    array_fill_keys(array_column($fields, 'name'), 'N/A')\n+                );\n+            }\n+        }\n+\n+        session(['extracted_data' => $extractedData]);\n+\n+        return view('pdf.results', compact('extractedData'));\n+    }\n+\n+    private function extractFieldValue(?string $text, ?string $start, ?string $end): string\n+{\n+    if (empty($text) || empty($start)) {\n+        return 'Not found';\n+    }\n+\n+    $start = preg_quote($start, '/');\n+    $end = $end ? preg_quote($end, '/') : null;\n+\n+    if ($end) {\n+        $pattern = '/' . $start . '\\s*(.*?)\\s*' . $end . '/su';\n+    } else {\n+        $pattern = '/' . $start . '\\s*([^\\r\\n]+)/su';\n+    }\n+\n+    if (preg_match($pattern, $text, $matches)) {\n+        return trim($matches[1]) ?: 'Empty';\n+    }\n+\n+    return 'Not found';\n+}\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1762472188149,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,10 +24,9 @@\n     {\n         $request->validate([\n             'fields' => 'required|array|min:1',\n             'fields.*.name' => 'required|string|max:255',\n-            'fields.*.start_keyword' => 'nullable|string',\n-            'fields.*.end_keyword' => 'nullable|string',\n+            'fields.*.start_keyword' => 'required|string',\n         ]);\n \n         $fields = $request->input('fields', []);\n         $uploadedPdfs = session('uploaded_pdfs', []);\n@@ -37,73 +36,143 @@\n                 ->with('error', 'Please upload PDFs and define fields first.');\n         }\n \n         $extractedData = [];\n-        $parser = new Parser;\n+        $parser = new Parser();\n \n         foreach ($uploadedPdfs as $pdfInfo) {\n             $filename = is_array($pdfInfo) ? $pdfInfo['filename'] : $pdfInfo;\n-            $pdfPath = Storage::disk('public')->path('pdf/'.$filename);\n+            $originalName = is_array($pdfInfo) ? $pdfInfo['original_name'] : $pdfInfo;\n+            $pdfPath = Storage::disk('public')->path('pdf/' . $filename);\n \n             try {\n-                if (! file_exists($pdfPath)) {\n-                    $extractedData[] = array_merge(\n-                        ['file' => $filename, 'status' => 'File not found'],\n-                        array_fill_keys(array_column($fields, 'name'), 'N/A')\n-                    );\n-\n+                if (!file_exists($pdfPath)) {\n+                    $extractedData[] = $this->createErrorRow($originalName, 'File not found', $fields);\n                     continue;\n                 }\n \n                 $pdf = $parser->parseFile($pdfPath);\n                 $text = $pdf->getText();\n \n+                if (empty(trim($text))) {\n+                    $extractedData[] = $this->createErrorRow($originalName, 'Empty PDF', $fields);\n+                    continue;\n+                }\n+\n                 $pdfResult = [\n-                    'file' => is_array($pdfInfo) ? $pdfInfo['original_name'] : $filename,\n-                    'status' => 'Success',\n+                    'file' => $originalName,\n+                    'status' => 'Success'\n                 ];\n \n+                // استخراج كل حقل\n                 foreach ($fields as $field) {\n                     $pdfResult[$field['name']] = $this->extractFieldValue(\n                         $text,\n-                        $field['start_keyword'] ?? null,\n-                        $field['end_keyword'] ?? null\n+                        $field['start_keyword']\n                     );\n                 }\n \n                 $extractedData[] = $pdfResult;\n \n             } catch (\\Exception $e) {\n-                $extractedData[] = array_merge(\n-                    ['file' => $filename, 'status' => 'Error: '.$e->getMessage()],\n-                    array_fill_keys(array_column($fields, 'name'), 'N/A')\n-                );\n+                \\Log::error('PDF Extraction Error: ' . $e->getMessage());\n+                $extractedData[] = $this->createErrorRow($originalName, 'Error: ' . $e->getMessage(), $fields);\n             }\n         }\n \n         session(['extracted_data' => $extractedData]);\n \n         return view('pdf.results', compact('extractedData'));\n     }\n \n-    private function extractFieldValue(?string $text, ?string $start, ?string $end): string\n+    /**\n+     * استخراج قيمة الحقل - النسخة المحسّنة\n+     *\n+     * @param string $text نص PDF\n+     * @param string $keyword الكلمة المفتاحية (مثل \"Name:\")\n+     * @return string القيمة المستخرجة\n+     */\n+    private function extractFieldValue(string $text, string $keyword): string\n     {\n-        if (empty($text) || empty($start)) {\n+        if (empty($text) || empty($keyword)) {\n             return 'Not found';\n         }\n \n-        $start = preg_quote($start, '/');\n-        $end = $end ? preg_quote($end, '/') : null;\n+        // تنظيف الكلمة المفتاحية\n+        $keyword = trim($keyword);\n \n-        if ($end) {\n-            $pattern = '/'.$start.'\\s*(.*?)\\s*'.$end.'/su';\n-        } else {\n-            $pattern = '/'.$start.'\\s*([^\\r\\n]+)/su';\n+        // Pattern 1: استخراج حتى نهاية السطر (الطريقة الأساسية)\n+        // يبحث عن الكلمة المفتاحية ويستخرج كل شيء حتى نهاية السطر\n+        $pattern = '/' . preg_quote($keyword, '/') . '\\s*([^\\n\\r]+)/ui';\n+\n+        if (preg_match($pattern, $text, $matches)) {\n+            $value = trim($matches[1]);\n+\n+            // إزالة أي كلمات مفتاحية أخرى قد تكون في نفس السطر\n+            // مثال: \"Name: John Age: 22\" -> نأخذ فقط \"John\"\n+            $value = preg_split('/\\s+(Name:|Age:|Gender:|Phone:|Email:|Address:|ID:|Code:)/i', $value, 2)[0];\n+            $value = trim($value);\n+\n+            return empty($value) ? 'Empty' : $value;\n         }\n \n+        // Pattern 2: محاولة بحث غير حساسة لحالة الأحرف\n+        $pattern = '/' . preg_quote($keyword, '/') . '\\s*([^\\n\\r]+)/i';\n+\n         if (preg_match($pattern, $text, $matches)) {\n-            return trim($matches[1]) ?: 'Empty';\n+            $value = trim($matches[1]);\n+            $value = preg_split('/\\s+(Name:|Age:|Gender:|Phone:|Email:|Address:|ID:|Code:)/i', $value, 2)[0];\n+            $value = trim($value);\n+\n+            return empty($value) ? 'Empty' : $value;\n         }\n \n         return 'Not found';\n     }\n+\n+    /**\n+     * إنشاء صف خطأ مع جميع الحقول\n+     */\n+    private function createErrorRow(string $filename, string $errorMsg, array $fields): array\n+    {\n+        $row = [\n+            'file' => $filename,\n+            'status' => $errorMsg\n+        ];\n+\n+        foreach ($fields as $field) {\n+            $row[$field['name']] = 'N/A';\n+        }\n+\n+        return $row;\n+    }\n+\n+    /**\n+     * استخراج متقدم (Advanced) - للاستخدام المستقبلي\n+     * يمكن استخدام هذه الطريقة للحقول المعقدة\n+     */\n+    private function advancedExtract(string $text, string $keyword, ?string $endKeyword = null): string\n+    {\n+        $lines = preg_split('/\\r\\n|\\r|\\n/', $text);\n+\n+        foreach ($lines as $line) {\n+            $line = trim($line);\n+\n+            // البحث عن الكلمة المفتاحية\n+            if (stripos($line, $keyword) !== false) {\n+                // استخراج القيمة\n+                $value = preg_replace('/' . preg_quote($keyword, '/') . '/i', '', $line);\n+                $value = trim($value);\n+\n+                // إذا كان هناك end keyword\n+                if ($endKeyword) {\n+                    $value = explode($endKeyword, $value)[0];\n+                    $value = trim($value);\n+                }\n+\n+                return empty($value) ? 'Empty' : $value;\n+            }\n+        }\n+\n+        return 'Not found';\n+    }\n }\n"
                },
                {
                    "date": 1762472199531,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,170 @@\n+<?php\n+\n+namespace App\\Http\\Controllers;\n+\n+use Illuminate\\Http\\Request;\n+use Illuminate\\Support\\Facades\\Storage;\n+use Smalot\\PdfParser\\Parser;\n+\n+class ExtractController extends Controller\n+{\n+    public function showFieldsForm()\n+    {\n+        $uploadedPdfs = session('uploaded_pdfs', []);\n+\n+        if (empty($uploadedPdfs)) {\n+            return redirect()->route('pdf.upload')\n+                ->with('error', 'Please upload at least one PDF first.');\n+        }\n+\n+        return view('pdf.fields', compact('uploadedPdfs'));\n+    }\n+\n+    public function extractData(Request $request)\n+    {\n+        $request->validate([\n+            'fields' => 'required|array|min:1',\n+            'fields.*.name' => 'required|string|max:255',\n+            'fields.*.start_keyword' => 'required|string',\n+        ]);\n+\n+        $fields = $request->input('fields', []);\n+        $uploadedPdfs = session('uploaded_pdfs', []);\n+\n+        if (empty($uploadedPdfs) || empty($fields)) {\n+            return redirect()->back()\n+                ->with('error', 'Please upload PDFs and define fields first.');\n+        }\n+\n+        $extractedData = [];\n+        $parser = new Parser();\n+\n+        foreach ($uploadedPdfs as $pdfInfo) {\n+            $filename = is_array($pdfInfo) ? $pdfInfo['filename'] : $pdfInfo;\n+            $originalName = is_array($pdfInfo) ? $pdfInfo['original_name'] : $pdfInfo;\n+            $pdfPath = Storage::disk('public')->path('pdf/' . $filename);\n+\n+            try {\n+                if (!file_exists($pdfPath)) {\n+                    $extractedData[] = $this->createErrorRow($originalName, 'File not found', $fields);\n+                    continue;\n+                }\n+\n+                $pdf = $parser->parseFile($pdfPath);\n+                $text = $pdf->getText();\n+\n+                if (empty(trim($text))) {\n+                    $extractedData[] = $this->createErrorRow($originalName, 'Empty PDF', $fields);\n+                    continue;\n+                }\n+\n+                $pdfResult = [\n+                    'file' => $originalName,\n+                    'status' => 'Success'\n+                ];\n+\n+                // استخراج كل حقل\n+                foreach ($fields as $field) {\n+                    $pdfResult[$field['name']] = $this->extractFieldValue(\n+                        $text,\n+                        $field['start_keyword']\n+                    );\n+                }\n+\n+                $extractedData[] = $pdfResult;\n+\n+            } catch (\\Exception $e) {\n+                \\Log::error('PDF Extraction Error: ' . $e->getMessage());\n+                $extractedData[] = $this->createErrorRow($originalName, 'Error: ' . $e->getMessage(), $fields);\n+            }\n+        }\n+\n+        session(['extracted_data' => $extractedData]);\n+\n+        return view('pdf.results', compact('extractedData'));\n+    }\n+\n+    /**\n+     * استخراج قيمة الحقل - النسخة المحسّنة\n+     *\n+     * @param string $text نص PDF\n+     * @param string $keyword الكلمة المفتاحية (مثل \"Name:\")\n+     * @return string القيمة المستخرجة\n+     */\n+    private function extractFieldValue(string $text, string $keyword): string\n+    {\n+        if (empty($text) || empty($keyword)) {\n+            return 'Not found';\n+        }\n+\n+        // تنظيف الكلمة المفتاحية\n+        $keyword = trim($keyword);\n+\n+        // Pattern 1: استخراج حتى نهاية السطر (الطريقة الأساسية)\n+        // يبحث عن الكلمة المفتاحية ويستخرج كل شيء حتى نهاية السطر\n+        $pattern = '/' . preg_quote($keyword, '/') . '\\s*([^\\n\\r]+)/ui';\n+\n+        if (preg_match($pattern, $text, $matches)) {\n+            $value = trim($matches[1]);\n+\n+            // إزالة أي كلمات مفتاحية أخرى قد تكون في نفس السطر\n+            // مثال: \"Name: John Age: 22\" -> نأخذ فقط \"John\"\n+            $value = preg_split('/\\s+(Name:|Age:|Gender:|Phone:|Email:|Address:|ID:|Code:)/i', $value, 2)[0];\n+            $value = trim($value);\n+\n+            return empty($value) ? 'Empty' : $value;\n+        }\n+\n+        // Pattern 2: محاولة بحث غير حساسة لحالة الأحرف\n+        $pattern = '/' . preg_quote($keyword, '/') . '\\s*([^\\n\\r]+)/i';\n+\n+        if (preg_match($pattern, $text, $matches)) {\n+            $value = trim($matches[1]);\n+            $value = preg_split('/\\s+(Name:|Age:|Gender:|Phone:|Email:|Address:|ID:|Code:)/i', $value, 2)[0];\n+            $value = trim($value);\n+\n+            return empty($value) ? 'Empty' : $value;\n+        }\n+\n+        return 'Not found';\n+    }\n+\n+    /**\n+     * إنشاء صف خطأ مع جميع الحقول\n+     */\n+    private function createErrorRow(string $filename, string $errorMsg, array $fields): array\n+    {\n+        $row = [\n+            'file' => $filename,\n+            'status' => $errorMsg\n+        ];\n+\n+        foreach ($fields as $field) {\n+            $row[$field['name']] = 'N/A';\n+        }\n+\n+        return $row;\n+    }\n+    private function advancedExtract(string $text, string $keyword, ?string $endKeyword = null): string\n+    {\n+        $lines = preg_split('/\\r\\n|\\r|\\n/', $text);\n+\n+        foreach ($lines as $line) {\n+            $line = trim($line);\n+\n+            if (stripos($line, $keyword) !== false) {\n+                $value = preg_replace('/' . preg_quote($keyword, '/') . '/i', '', $line);\n+                $value = trim($value);\n+\n+                if ($endKeyword) {\n+                    $value = explode($endKeyword, $value)[0];\n+                    $value = trim($value);\n+                }\n+\n+                return empty($value) ? 'Empty' : $value;\n+            }\n+        }\n+\n+        return 'Not found';\n+    }\n+}\n\\ No newline at end of file\n"
                }
            ],
            "date": 1762469552741,
            "name": "Commit-0",
            "content": "<?php\nnamespace App\\Http\\Controllers;\n\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Storage;\nuse Smalot\\PdfParser\\Parser;\n\nclass ExtractController extends Controller\n{\n    public function showFieldsForm()\n    {\n        $uploadedPdfs = session('uploaded_pdfs', []);\n\n        if (empty($uploadedPdfs)) {\n            return redirect()->route('pdf.upload')\n                ->with('error', 'Please upload at least one PDF first.');\n        }\n\n        return view('pdf.fields', compact('uploadedPdfs'));\n    }\n\n    public function extractData(Request $request)\n    {\n        $request->validate([\n            'fields' => 'required|array|min:1',\n            'fields.*.name' => 'required|string|max:255',\n            'fields.*.start_keyword' => 'nullable|string',\n            'fields.*.end_keyword' => 'nullable|string',\n        ]);\n\n        $fields = $request->input('fields', []);\n        $uploadedPdfs = session('uploaded_pdfs', []);\n\n        if (empty($uploadedPdfs) || empty($fields)) {\n            return redirect()->back()\n                ->with('error', 'Please upload PDFs and define fields first.');\n        }\n\n        $extractedData = [];\n        $parser = new Parser();\n\n        foreach ($uploadedPdfs as $pdfInfo) {\n            $filename = is_array($pdfInfo) ? $pdfInfo['filename'] : $pdfInfo;\n            $pdfPath = Storage::disk('public')->path('pdf/' . $filename);\n\n            try {\n                // Check if file exists\n                if (!file_exists($pdfPath)) {\n                    $extractedData[] = array_merge(\n                        ['file' => $filename, 'status' => 'File not found'],\n                        array_fill_keys(array_column($fields, 'name'), 'N/A')\n                    );\n                    continue;\n                }\n\n                $pdf = $parser->parseFile($pdfPath);\n                $text = $pdf->getText();\n\n                $pdfResult = [\n                    'file' => is_array($pdfInfo) ? $pdfInfo['original_name'] : $filename,\n                    'status' => 'Success'\n                ];\n\n                foreach ($fields as $field) {\n                    $pdfResult[$field['name']] = $this->extractFieldValue(\n                        $text,\n                        $field['start_keyword'] ?? null,\n                        $field['end_keyword'] ?? null\n                    );\n                }\n\n                $extractedData[] = $pdfResult;\n\n            } catch (\\Exception $e) {\n                $extractedData[] = array_merge(\n                    ['file' => $filename, 'status' => 'Error: ' . $e->getMessage()],\n                    array_fill_keys(array_column($fields, 'name'), 'N/A')\n                );\n            }\n        }\n\n        session(['extracted_data' => $extractedData]);\n\n        return view('pdf.results', compact('extractedData'));\n    }\n\n    private function extractFieldValue(?string $text, ?string $start, ?string $end): string\n    {\n        if (empty($text) || empty($start)) {\n            return 'Not found';\n        }\n\n        $start = preg_quote($start, '/');\n        $end = $end ? preg_quote($end, '/') : '$';\n\n        // Add word boundaries and better whitespace handling\n        $pattern = '/' . $start . '\\s*(.*?)' . $end . '/su';\n\n        if (preg_match($pattern, $text, $matches)) {\n            return trim($matches[1]) ?: 'Empty';\n        }\n\n        return 'Not found';\n    }\n}"
        }
    ]
}